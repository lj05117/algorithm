# 문제

- 1행 1열에 있는 캐릭터를 n행 m열의 상대방 진영에 도착하게 하기 위해 지나가야 하는 칸의 최솟값을 반환하는 문제
- 도착하지 못하는 경우 -1 반환

문제 링크 : https://school.programmers.co.kr/learn/courses/30/lessons/1844

# 풀이

- 입력된 배열의 행, 열 길이 구하기
- 사방 탐색을 위한 행, 열 배열 생성
- 탐색 배열에 행, 열, 이동 거리가 0 인 배열 원소 넣기

- 탐색 배열 길이만큼 반복문
  - x, y, cnt에 배열의 첫번째 원소 대입 및 원소 삭제
  - 목적지에 도착한 원소면 최소값 계산
    - 이전 값과 현재 값 중 최소값을 answer로 설정
    - 반복문 다시 시작
  - 사방탐색
    - 현재 인덱스의 방향으로 1칸 이동
    - 인덱스 범위 확인
    - 이동할수 있는 곳인가?
      - 탐색 배열에 이동할 위치, 이동거리+1 push
      - 이동 한 곳으로 표시
- -1 혹은 answer 반환

# 결과

## 목적지 도달 후 사방탐색 o

![image](https://github.com/lj05117/algorithm/assets/58285947/2e08d830-b6be-4b97-a9f3-adf808147a5a)

## 목적지 도달 후 사방탐색 x

![image](https://github.com/lj05117/algorithm/assets/58285947/e77d58f2-7342-4714-96ef-3d23d0b67f78)
시간이나 메모리가 조금씩 늘어나는 경우도 있지만, 테스트 2의 경우 시간이 확연히 줄어든 것을 볼 수 있다.

# 후기

- 최단 거리를 구하는 알고리즘은 bfs라는 것을 기억하자.
- dfs는 구조 탐색 혹은 경로 존재 여부!
